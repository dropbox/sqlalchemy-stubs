from typing import Any, Optional, Dict, TypeVar

def md5_hex(x): ...

class safe_reraise(object):
    def __enter__(self): ...
    def __exit__(self, type_, value, traceback): ...

def decode_slice(slc): ...
def map_bits(fn, n): ...
def decorator(target): ...
def public_factory(target, location): ...

class PluginLoader(object):
    group: Any = ...
    impls: Any = ...
    auto_fn: Any = ...
    def __init__(self, group, auto_fn: Optional[Any] = ...) -> None: ...
    def load(self, name): ...
    def register(self, name, modulepath, objname): ...

def get_cls_kwargs(cls, _set: Optional[Any] = ...): ...
def inspect_func_args(fn): ...
def get_func_kwargs(func): ...
def get_callable_argspec(fn, no_self: bool = ..., _is_init: bool = ...): ...
def format_argspec_plus(fn, grouped: bool = ...): ...
def format_argspec_init(method, grouped: bool = ...): ...
def getargspec_init(method): ...
def unbound_method_to_callable(func_or_cls): ...
def generic_repr(obj, additional_kw: Any = ..., to_inspect: Optional[Any] = ..., omit_kwarg: Any = ...): ...

class portable_instancemethod(object):
    target: Any = ...
    name: Any = ...
    def __init__(self, meth) -> None: ...
    def __call__(self, *arg, **kw): ...

def class_hierarchy(cls): ...
def iterate_attributes(cls): ...
def monkeypatch_proxied_specials(into_cls, from_cls, skip: Optional[Any] = ..., only: Optional[Any] = ..., name: str = ...,
                                 from_instance: Optional[Any] = ...): ...
def methods_equivalent(meth1, meth2): ...
def as_interface(obj, cls: Optional[Any] = ..., methods: Optional[Any] = ..., required: Optional[Any] = ...): ...

class memoized_property(object):
    fget: Any = ...
    __doc__: Any = ...
    __name__: Any = ...
    def __init__(self, fget, doc: Optional[Any] = ...) -> None: ...
    def __get__(self, obj, cls): ...
    @classmethod
    def reset(cls, obj, name): ...

def memoized_instancemethod(fn): ...

class group_expirable_memoized_property(object):
    attributes: Any = ...
    def __init__(self, attributes: Any = ...) -> None: ...
    def expire_instance(self, instance): ...
    def __call__(self, fn): ...
    def method(self, fn): ...

class MemoizedSlots(object):
    def __getattr__(self, key): ...

def dependency_for(modulename): ...

class dependencies(object):
    import_deps: Any = ...
    def __init__(self, *deps) -> None: ...
    def __call__(self, fn): ...
    @classmethod
    def resolve_all(cls, path): ...

def asbool(obj): ...
def bool_or_str(*text): ...
def asint(value): ...
def coerce_kw_type(kw, key, type_, flexi_bool: bool = ...): ...
def constructor_copy(obj, cls, *args, **kw): ...
def counter(): ...
def duck_type_collection(specimen, default: Optional[Any] = ...): ...
def assert_arg_type(arg, argtype, name): ...
def dictlike_iteritems(dictlike): ...

class classproperty(property):
    __doc__: str = ...
    def __init__(self, fget, *arg, **kw) -> None: ...
    def __get__(desc, self, cls): ...

class hybridproperty(object):
    func: Any = ...
    def __init__(self, func) -> None: ...
    def __get__(self, instance, owner): ...

class hybridmethod(object):
    func: Any = ...
    def __init__(self, func) -> None: ...
    def __get__(self, instance, owner): ...

class symbol(object):
    symbols: Dict[str, Any]
    def __new__(cls, name, doc: Optional[Any] = ..., canonical: Optional[Any] = ...): ...

def set_creation_order(instance): ...
def warn_exception(func, *args, **kwargs): ...
def ellipses_string(value, len_: int = ...): ...

def warn(msg): ...
def warn_limited(msg, args): ...
def only_once(fn): ...
def chop_traceback(tb, exclude_prefix: Any = ..., exclude_suffix: Any = ...): ...

NoneType = type(None)

def attrsetter(attrname): ...

class EnsureKWArgType(type):
    def __init__(cls, clsname, bases, clsdict) -> None: ...

def wrap_callable(wrapper, fn): ...
