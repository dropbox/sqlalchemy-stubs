from typing import Any, Optional, Union, Iterable, Tuple, TypeVar, Generic, overload
from .base import Executable as Executable, ColumnCollection
from .elements import ColumnElement as ColumnElement, Grouping, ClauseList, ColumnElement, Over, WithinGroup, FunctionFilter
from .selectable import FromClause as FromClause, Alias, Select
from . import util as sqlutil
from .visitors import VisitableType as VisitableType
from .type_api import TypeEngine
from .schema import Sequence
from . import sqltypes
from ..engine.result import ResultProxy

_T = TypeVar('_T')

def register_function(identifier, fn, package: str = ...): ...

class FunctionElement(Executable, ColumnElement[_T], FromClause, Generic[_T]):  # type: ignore
    # ColumnElement.foreign_keys() is not compatible with FromClause.foreign_keys()
    packagenames: Any = ...
    clause_expr: Grouping[Any] = ...
    def __init__(self, *clauses: Any, **kwargs: Any) -> None: ...
    # Return type of "columns" incompatible with supertype "FromClause"
    @property
    def columns(self) -> ColumnCollection: ...  # type: ignore
    @property
    def clauses(self) -> ClauseList: ...
    @overload
    def over(self, partition_by: Optional[Union[str, ColumnElement[Any], Iterable[Union[str, ColumnElement[Any]]]]] = ...,
             order_by: Optional[Union[str, ColumnElement[Any], Iterable[Union[str, ColumnElement[Any]]]]] = ...,
             range_: Optional[Tuple[Optional[int], Optional[int]]] = ...) -> Over[_T]: ...
    @overload
    def over(self, partition_by: Optional[Union[str, ColumnElement[Any], Iterable[Union[str, ColumnElement[Any]]]]] = ...,
             order_by: Optional[Union[str, ColumnElement[Any], Iterable[Union[str, ColumnElement[Any]]]]] = ...,
             rows: Optional[Tuple[Optional[int], Optional[int]]] = ...) -> Over[_T]: ...
    def within_group(self, *order_by: Union[str,
                                            ColumnElement[Any],
                                            Iterable[Union[str, ColumnElement[Any]]]]) -> WithinGroup[_T]: ...
    @overload
    def filter(self) -> FunctionElement[_T]: ...
    @overload
    def filter(self, criteria: Any, *criterion: Any) -> FunctionFilter[_T]: ...
    def get_children(self, **kwargs: Any) -> Tuple[Grouping[Any]]: ...
    def within_group_type(self, within_group: Any) -> Any: ...
    def alias(self, name: Optional[str] = ..., flat: bool = ...) -> Alias: ...
    def select(self) -> Select: ...  # type: ignore  # incompatible with FromClause.select
    def scalar(self) -> Any: ...  # type: ignore  # incompatible with Executable.scalar
    def execute(self) -> ResultProxy: ...  # type: ignore  # incompatible with Executable.execute
    def self_group(self, against: Optional[Any] = ...) -> Union[ColumnElement[_T], Grouping[_T]]: ...

class _FunctionGenerator(object):
    opts: Any = ...
    def __init__(self, **opts: Any) -> None: ...
    def __getattr__(self, name: str) -> Any: ...
    def __call__(self, *c: Any, **kwargs: Any) -> Function[Any]: ...

func: _FunctionGenerator = ...
modifier: _FunctionGenerator = ...

class Function(FunctionElement[_T]):
    __visit_name__: str = ...
    packagenames: Any = ...
    name: str = ...
    type: TypeEngine[_T] = ...
    def __init__(self, name: str, *clauses: Any, **kw: Any) -> None: ...

class _GenericMeta(VisitableType):
    def __init__(cls, clsname, bases, clsdict) -> None: ...

class GenericFunction(Function[_T], metaclass=_GenericMeta):
    coerce_arguments: bool = ...
    packagenames: Any = ...
    clause_expr: Grouping[Any] = ...
    type: TypeEngine[_T] = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...

class next_value(GenericFunction[_T]):
    type: TypeEngine[_T] = ...
    name: str = ...
    sequence: Sequence[_T] = ...
    def __init__(self, seq: Sequence[_T], **kw) -> None: ...

class AnsiFunction(GenericFunction[_T]):
    def __init__(self, **kwargs) -> None: ...

class ReturnTypeFromArgs(GenericFunction[_T]):
    def __init__(self, *args, **kwargs) -> None: ...

class coalesce(ReturnTypeFromArgs[Any]): ...
class max(ReturnTypeFromArgs[Any]): ...
class min(ReturnTypeFromArgs[Any]): ...
class sum(ReturnTypeFromArgs[Any]): ...

class now(GenericFunction[sqltypes.DateTime]): ...

class concat(GenericFunction[sqltypes.String]): ...

class char_length(GenericFunction[sqltypes.Integer]): ...

class random(GenericFunction[_T]): ...

class count(GenericFunction[sqltypes.Integer]):
    def __init__(self, expression: Optional[Any] = ..., **kwargs: Any) -> None: ...

class current_date(AnsiFunction[sqltypes.Date]): ...

class current_time(AnsiFunction[sqltypes.Time]): ...

class current_timestamp(AnsiFunction[sqltypes.DateTime]): ...

class current_user(AnsiFunction[sqltypes.String]): ...

class localtime(AnsiFunction[sqltypes.DateTime]): ...

class localtimestamp(AnsiFunction[sqltypes.DateTime]): ...

class session_user(AnsiFunction[sqltypes.String]): ...

class sysdate(AnsiFunction[sqltypes.DateTime]): ...

class user(AnsiFunction[sqltypes.String]): ...

class array_agg(GenericFunction[sqltypes.ARRAY[_T]], Generic[_T]): ...

class OrderedSetAgg(GenericFunction[_T]):
    array_for_multi_clause: bool = ...
    def within_group_type(self, within_group: WithinGroup[_T]) -> Union[TypeEngine[_T], sqltypes.ARRAY[_T]]: ...

class mode(OrderedSetAgg[_T]):
    def within_group_type(self, within_group: WithinGroup[_T]) -> TypeEngine[_T]: ...

class percentile_cont(OrderedSetAgg[Any]): ...

class percentile_disc(OrderedSetAgg[Any]): ...

class rank(GenericFunction[sqltypes.Integer]): ...

class dense_rank(GenericFunction[sqltypes.Integer]): ...

class percent_rank(GenericFunction[sqltypes.Numeric]): ...

class cume_dist(GenericFunction[sqltypes.Numeric]): ...
