from typing import Any, Optional, Union, TypeVar, Dict, List, Callable, Type, overload, Text as typing_Text
from .type_api import TypeEngine as TypeEngine, TypeDecorator as TypeDecorator
from .base import SchemaEventTarget as SchemaEventTarget
from datetime import datetime, date, time, timedelta
from ..engine import Dialect
from .. import util
import decimal
import sys

_T = TypeVar('_T')

class _DateAffinity(object):
    comparator_factory: Any = ...

class Concatenable(object):
    comparator_factory: Any = ...

class Indexable(object):
    comparator_factory: Any = ...

# Docs say that String is unicode when DBAPI supports it
# but it should be all major DBAPIs now.
class String(Concatenable, TypeEngine[typing_Text]):
    __visit_name__: str = ...
    length: Optional[int] = ...
    collation: Optional[str] = ...
    convert_unicode: Union[bool, str] = ...
    unicode_error: Optional[str] = ...
    @overload
    def __init__(self, length: Optional[int] = ..., collation: Optional[str] = ...,
                 convert_unicode: bool = ..., _warn_on_bytestring: bool = ...) -> None: ...
    @overload
    def __init__(self, length: Optional[int] = ..., collation: Optional[str] = ...,
                 convert_unicode: str = ..., unicode_error: Optional[str] = ...,
                 _warn_on_bytestring: bool = ...) -> None: ...
    def literal_processor(self, dialect: Dialect) -> Callable[[str], str]: ...
    def bind_processor(self, dialect: Dialect) -> Optional[Callable[[str], str]]: ...
    def result_processor(self, dialect: Dialect, coltype: Any): ...
    @property
    def python_type(self) -> Type[typing_Text]: ...
    def get_dbapi_type(self, dbapi): ...

class Text(String):
    __visit_name__: str = ...

class Unicode(String):
    __visit_name__: str = ...
    @overload
    def __init__(self, length: Optional[int] = ..., collation: Optional[str] = ...,
                 convert_unicode: bool = ..., _warn_on_bytestring: bool = ...) -> None: ...
    @overload
    def __init__(self, length: Optional[int] = ..., collation: Optional[str] = ...,
                 convert_unicode: str = ..., unicode_error: Optional[str] = ...,
                 _warn_on_bytestring: bool = ...) -> None: ...

class UnicodeText(Text):
    __visit_name__: str = ...
    @overload
    def __init__(self, length: Optional[int] = ..., collation: Optional[str] = ...,
                 convert_unicode: bool = ..., _warn_on_bytestring: bool = ...) -> None: ...
    @overload
    def __init__(self, length: Optional[int] = ..., collation: Optional[str] = ...,
                 convert_unicode: str = ..., unicode_error: Optional[str] = ...,
                 _warn_on_bytestring: bool = ...) -> None: ...

class Integer(_DateAffinity, TypeEngine[int]):
    __visit_name__: str = ...
    def get_dbapi_type(self, dbapi): ...
    @property
    def python_type(self) -> Type[int]: ...
    def literal_processor(self, dialect: Dialect) -> Callable[[int], str]: ...

class SmallInteger(Integer):
    __visit_name__: str = ...

class BigInteger(Integer):
    __visit_name__: str = ...

class Numeric(_DateAffinity, TypeEngine[float]):  # TODO: this can be also decimal.Decimal
    __visit_name__: str = ...
    precision: Any = ...
    scale: Any = ...
    decimal_return_scale: Any = ...
    asdecimal: Any = ...
    def __init__(self, precision: Optional[Any] = ..., scale: Optional[Any] = ...,
                 decimal_return_scale: Optional[Any] = ..., asdecimal: bool = ...) -> None: ...
    def get_dbapi_type(self, dbapi): ...
    def literal_processor(self, dialect: Dialect) -> Callable[[Union[float, decimal.Decimal]], str]: ...
    @property
    def python_type(self) -> Union[Type[float], Type[decimal.Decimal]]: ...  # type: ignore  # return type incompatible
    def bind_processor(self, dialect: Dialect) -> Optional[Callable[[Optional[str]], float]]: ...
    def result_processor(self, dialect: Dialect, coltype: Any): ...

class Float(Numeric):
    __visit_name__: str = ...
    scale: Any = ...
    precision: Any = ...
    asdecimal: Any = ...
    decimal_return_scale: Any = ...
    def __init__(self, precision: Optional[Any] = ..., asdecimal: bool = ...,
                 decimal_return_scale: Optional[Any] = ..., **kwargs) -> None: ...
    def result_processor(self, dialect: Dialect, coltype: Any): ...

class DateTime(_DateAffinity, TypeEngine[datetime]):
    __visit_name__: str = ...
    timezone: Any = ...
    def __init__(self, timezone: bool = ...) -> None: ...
    def get_dbapi_type(self, dbapi): ...
    @property
    def python_type(self) -> Type[datetime]: ...

class Date(_DateAffinity, TypeEngine[date]):
    __visit_name__: str = ...
    def get_dbapi_type(self, dbapi): ...
    @property
    def python_type(self) -> Type[date]: ...

class Time(_DateAffinity, TypeEngine[time]):
    __visit_name__: str = ...
    timezone: bool = ...
    def __init__(self, timezone: bool = ...) -> None: ...
    def get_dbapi_type(self, dbapi): ...
    @property
    def python_type(self) -> Type[time]: ...

if sys.version_info[0] < 3:
    _BinaryType = str
else:
    _BinaryType = bytes

class _Binary(TypeEngine[_BinaryType]):
    length: int = ...
    def __init__(self, length: Optional[int] = ...) -> None: ...
    def literal_processor(self, dialect: Dialect) -> Callable[[_BinaryType], str]: ...
    @property
    def python_type(self) -> Type[_BinaryType]: ...
    def bind_processor(self, dialect: Dialect) -> Optional[Callable[[_BinaryType], Any]]: ...
    def result_processor(self, dialect: Dialect, coltype: Any): ...
    def coerce_compared_value(self, op, value): ...
    def get_dbapi_type(self, dbapi): ...

class LargeBinary(_Binary):
    __visit_name__: str = ...
    def __init__(self, length: Optional[int] = ...) -> None: ...

class Binary(LargeBinary):
    def __init__(self, length: Optional[int] = ...) -> None: ...

class SchemaType(SchemaEventTarget):
    name: Any = ...
    schema: Any = ...
    metadata: Any = ...
    inherit_schema: Any = ...
    def __init__(self, name: Optional[Any] = ..., schema: Optional[Any] = ...,
                 metadata: Optional[Any] = ..., inherit_schema: bool = ...,
                 quote: Optional[Any] = ..., _create_events: bool = ...) -> None: ...
    def copy(self, **kw): ...
    def adapt(self, *args, **kw): ...
    @property
    def bind(self): ...
    def create(self, bind: Optional[Any] = ..., checkfirst: bool = ...): ...
    def drop(self, bind: Optional[Any] = ..., checkfirst: bool = ...): ...

class Enum(String, SchemaType):
    __visit_name__: str = ...
    native_enum: bool = ...
    create_constraint: bool = ...
    validate_strings: bool = ...
    def __init__(self, *enums, **kw) -> None: ...
    comparator_factory: Any = ...
    def copy(self, **kw): ...
    def adapt(self, *args, **kw): ...
    def literal_processor(self, dialect): ...
    def bind_processor(self, dialect): ...
    def result_processor(self, dialect, coltype): ...
    @property
    def python_type(self): ...

class PickleType(TypeDecorator[Any]):
    impl: Any = ...
    protocol: Any = ...
    pickler: Any = ...
    comparator: Any = ...
    def __init__(self, protocol: Any = ..., pickler: Optional[Any] = ...,
                 comparator: Optional[Any] = ...) -> None: ...
    def __reduce__(self): ...
    def bind_processor(self, dialect): ...
    def result_processor(self, dialect, coltype): ...
    def compare_values(self, x, y): ...

class Boolean(TypeEngine[bool], SchemaType):
    __visit_name__: str = ...
    create_constraint: bool = ...
    name: str = ...
    def __init__(self, create_constraint: bool = ..., name: Optional[str] = ...,
                 _create_events: bool = ...) -> None: ...
    @property
    def python_type(self) -> Type[bool]: ...
    def literal_processor(self, dialect: Dialect) -> Callable[[Optional[bool]], str]: ...
    def bind_processor(self, dialect: Dialect) -> Callable[[Optional[bool]], Optional[Union[bool, int]]]: ...
    def result_processor(self, dialect: Dialect, coltype: Any) -> Optional[Callable[[Optional[int]], bool]]: ...

class Interval(_DateAffinity, TypeDecorator[timedelta]):
    impl: Any = ...
    epoch: Any = ...
    native: Any = ...
    second_precision: Any = ...
    day_precision: Any = ...
    def __init__(self, native: bool = ..., second_precision: Optional[Any] = ...,
                 day_precision: Optional[Any] = ...) -> None: ...
    def adapt(self, cls, **kw): ...
    @property
    def python_type(self) -> Type[timedelta]: ...
    def bind_processor(self, dialect): ...
    def result_processor(self, dialect, coltype): ...
    def coerce_compared_value(self, op, value): ...

class JSON(Indexable, TypeEngine[Dict[str, Any]]):
    __visit_name__: str = ...
    hashable: bool = ...
    NULL: util.symbol = ...
    none_as_null: bool = ...
    def __init__(self, none_as_null: bool = ...) -> None: ...
    class JSONElementType(TypeEngine[Union[int, str]]):
        def string_bind_processor(self, dialect): ...
        def string_literal_processor(self, dialect): ...
        def bind_processor(self, dialect): ...
        def literal_processor(self, dialect): ...
    class JSONIndexType(JSONElementType): ...
    class JSONPathType(JSONElementType): ...
    comparator_factory: Any = ...
    @property
    def python_type(self) -> Type[Dict[str, Any]]: ...
    @property
    def should_evaluate_none(self) -> bool: ...  # type: ignore  # incompatible with supertype "TypeEngine"
    def bind_processor(self, dialect): ...
    def result_processor(self, dialect, coltype): ...

class ARRAY(Indexable, Concatenable, TypeEngine[List[_T]]):
    __visit_name__: str = ...
    zero_indexes: bool = ...
    comparator_factory: Any = ...
    item_type: TypeEngine[_T] = ...
    as_tuple: bool = ...
    dimensions: Optional[int] = ...
    @overload
    def __init__(self, item_type: TypeEngine[_T], as_tuple: bool = ..., dimensions: Optional[int] = ...,
                 zero_indexes: bool = ...) -> None: ...
    @overload
    def __init__(self, item_type: Type[TypeEngine[_T]], as_tuple: bool = ..., dimensions: Optional[int] = ...,
                 zero_indexes: bool = ...) -> None: ...
    @property
    def hashable(self) -> bool: ...  # type: ignore  # incompatible with supertype "TypeEngine"
    @property
    def python_type(self) -> Type[list]: ...
    def compare_values(self, x: _T, y: _T) -> bool: ...

class REAL(Float):
    __visit_name__: str = ...

class FLOAT(Float):
    __visit_name__: str = ...

class NUMERIC(Numeric):
    __visit_name__: str = ...

class DECIMAL(Numeric):
    __visit_name__: str = ...

class INTEGER(Integer):
    __visit_name__: str = ...

INT = INTEGER

class SMALLINT(SmallInteger):
    __visit_name__: str = ...

class BIGINT(BigInteger):
    __visit_name__: str = ...

class TIMESTAMP(DateTime):
    __visit_name__: str = ...
    def __init__(self, timezone: bool = ...) -> None: ...
    def get_dbapi_type(self, dbapi): ...

class DATETIME(DateTime):
    __visit_name__: str = ...

class DATE(Date):
    __visit_name__: str = ...

class TIME(Time):
    __visit_name__: str = ...

class TEXT(Text):
    __visit_name__: str = ...

class CLOB(Text):
    __visit_name__: str = ...

class VARCHAR(String):
    __visit_name__: str = ...

class NVARCHAR(Unicode):
    __visit_name__: str = ...

class CHAR(String):
    __visit_name__: str = ...

class NCHAR(Unicode):
    __visit_name__: str = ...

class BLOB(LargeBinary):
    __visit_name__: str = ...

class BINARY(_Binary):
    __visit_name__: str = ...

class VARBINARY(_Binary):
    __visit_name__: str = ...

class BOOLEAN(Boolean):
    __visit_name__: str = ...

class NullType(TypeEngine[None]):
    __visit_name__: str = ...
    hashable: bool = ...
    def literal_processor(self, dialect): ...
    comparator_factory: Any = ...

class MatchType(Boolean): ...

NULLTYPE: NullType = ...
BOOLEANTYPE: Boolean = ...
STRINGTYPE: String = ...
INTEGERTYPE: Integer = ...
MATCHTYPE: MatchType = ...
